target C {
    timeout: 3 sec
}

reactor A1 {
    output out:float
    timer t(0, 1 sec)
    state count:int = 0
    reaction(t) -> out {=
        float v = 3.14;
        lf_set(out, v + self->count++);
        lf_print("(%lld) A1 sent %f", lf_time_logical_elapsed(), out->value);
    =}
}

reactor A2 {
    output out:float[2]
    timer t(0, 1 sec)
    state count:int = 0
    reaction(t) -> out {=
        float v[2] = {3.14, 3.15};
        out->value[0] = v[0] + self->count;
        out->value[1] = v[1] + self->count;
        self->count++;
        lf_set_present(out);
        lf_print("(%lld) A2 send [%f, %f]", lf_time_logical_elapsed(), out->value[0], out->value[1]);
    =}
}

reactor A3 {
    output out:double
    timer t(0, 1 sec)
    state count:int = 0
    reaction(t) -> out {=
        double v = 3.14;
        lf_set(out, v + self->count++);
        lf_print("(%lld) A3 sent %f", lf_time_logical_elapsed(), out->value);
    =}
}

reactor B1 {
    input in:float
    reaction(in) {=
        lf_print("(%lld) B1 received %f", lf_time_logical_elapsed(), in->value);
    =}
}

reactor B2 {
    input in:float[2]
    reaction(in) {=
        lf_print("(%lld) B2 received [%f, %f]", lf_time_logical_elapsed(), in->value[0], in->value[1]);
    =}
}

reactor B3 {
    input in:double
    reaction(in) {=
        lf_print("(%lld) B3 received %f", lf_time_logical_elapsed(), in->value);
    =}
}

main reactor {
    // a1 = new A1()
    // b1 = new B1()
    // a1.out -> b1.in // Works.

    // a2 = new A2()
    // b2 = new B2()
    // a2.out -> b2.in // Works.
    // a2.out -> b2.in after 1 sec // FIXME: Works by luck, since period = after delay.
    // a2.out -> b2.in after 2 sec // FIXME: Does not work.

    a3 = new A3()
    b3 = new B3()
    a3.out -> b3.in // Works.
}